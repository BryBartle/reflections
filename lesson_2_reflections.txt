Lesson 2 Reflections (Bry Bartle):

What happens when you initialize a repository? Why do you need to do it?
	
	When you initialize a git repository you create a .git file in the directory 
	you are currently in. This allows you to then creat commits of the files in 
	that directory in the git repository you have just created. You need the .git 
	file to be able to track these changes because it stores the required metadata.

How is the staging area different from the working directory and the repository?
What value do you think it offers?

	Staging area is where you store files that you are planning on including in 
	your next commit whereas the working directory includes both files in and 
	not in the staging area, and the repository just stores your commits - not 
	necessarily all files in the working directory because you may not commit 
	all of those files.
	The staging area offers great value because it allows you time to think and 
	visually see what is currently queued for your next commit. Thus, you can 
	look at what you are currently including and then see what logically makes 
	sense to include in that commit along with the files you already have queued.

How can you use the staging area to make sure you have one commit per logical
change?

	I can make changes in the working directory, then add whatever files I want 
	to the staging area. From here I can use git diff to make sure I'm including 
	only the changed files I want to commit in the staging area by comparying 
	my working directory files to my staging area files. I can then confirm that 
	I am only making one logical change since my last commit by using git diff 
	--staged to compare the current files in my staging area to the most recent 
	commit in my repository. This way I can see the changes that have been made 
	since my last commit and confirm that it is only one logical change.

What are some situations when branches would be helpful in keeping your history
organized? How would branches help?

	Branches can be very helpful when making different versions of the same 
	program that have different features (example an easy, average, and hard 
	version of a game). This is useful because you can do this from mostly the 
	same code and then just branch off and change one feature to change the 
	difficulty and still keep all easy, average and hard versions in different 
	branches (could also be any application, italian version of code, different 
	languages, same product tailored for different clients, etc.). This would 
	be super helpful in keeping things organized as you can keep different 
	variations of the same thing in different branches off the master branch.

How do the diagrams help you visualize the branch structure?

	The diagrams help me see where branches were started (what the parent 
	commit is) and which commits can be reached through each branch. It also 
	helps me to see if there are any unbranched and therefore unreachable 
	commits that could be lost if I don't create a branch for them (detached 
	HEADs).

What is the result of merging two branches together? Why do we represent it in
the diagram the way we do?

What are the pros and cons of Git’s automatic merging vs. always doing merges
manually?